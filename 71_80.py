# -*- coding: utf-8 -*-
"""71-80.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RP5DJ4eHEf5vCGvlj6VWHbH-uXM06R5N

# **71번 깊이 우선 탐색.**

이 우선 탐색으로 이 노드들을 탐색했을 때의 순서를 공백으로 구분하여 출력하는 프로그램을 완성하세요.


1. 빨간색으로 Pass라고 되어 있는 부분을 완성해주세요.

2. 깊이 우선 탐색을 오른쪽, 왼쪽 둘 다 구현해보세요.

3. 리스트로도 구현해보세요.

**깊이 우선 탐색**이란 목표한 노드를 찾기 위해 가장 우선순위가 높은 노드의 자식이므로 깊이 들어 갔다가 목표 노드가 존재하지 않으면 처음 방문한 노드와 연결된 다른 노드부터 그 자식노드로 파고드는 검색방법을 말한다.
"""

graph = {
        'A': set(['B', 'C', 'E']),
        'B': set(['A']),
        'C': set(['A']),
        'D': set(['E', 'F']),
        'E': set(['A', 'D']),
        'F': set(['D'])
}

def dfs(graph, start):
    visited = []
    stack = [start]

    while stack:
        n = stack.pop()
        if n not in visited:
            visited.append(n)
            stack += graph[n] - set(visited)
    return visited

print(dfs(graph, 'E'))

tree = {
        'A': ['B', 'C', 'E'],
        'B': ['A'],
        'C': ['A'],
        'D': ['E', 'F'],
        'E': ['A', 'D'],
        'F': ['D']
}

def dfs(data, start):
    visited = []
    stack = [start]

    pass

    return visited

print(dfs(tree, 'E'))

"""# **72번 너비 우선 탐색**

너비 우선 탐색을 한 순서대로 노드의 인덱스를 공백 구분으로 출력하는 프로그램을 완성해주세요.

**너비 우선 탐색**이란 어떤 노드를 방문하여 확인 한 후, 목표한 노드가 아니면 그 노드와 연결된 정점들 중에서 우선순위가 동일한 다른 노드를 찾고 그 순위에 없으면 그 다음 순위 노드를 차례대로 찾는 방법이다.
"""

graph = {
        'A': set(['B', 'C', 'E']),
        'B': set(['A']),
        'C': set(['A']),
        'D': set(['E', 'F']),
        'E': set(['A', 'D']),
        'F': set(['D'])
}

def bfs(graph, start):
    visited = []
    queue = [start]

    while queue:
        n = queue.pop(0)
        if n not in visited:
            visited.append(n)
            queue += graph[n] - set(visited)
    return visited

print(bfs(graph, 'E'))

"""# **73번 최단 경로 찾기**

두 정점 사이를 이동할 수 있는 최단거리를 출력하는 프로그램을 작성해 주세요. 
"""

graph = {'A': set(['B', 'C']),
         'B': set(['A', 'D', 'E']),
         'C': set(['A', 'F']),
         'D': set(['B']),
         'E': set(['B', 'F']),
         'F': set(['C', 'E'])}

start, end = [i for i in input().split()]
    
queue = [start]
visited = [start]
    
def solution():
    count = -1

    while len(queue)!=0:
        count += 1
        size = len(queue)

        for i in range(size):
            node = queue.pop(0)
            if node == end:
                return count

            for next_node in graph[node]:
                if next_node not in visited:
                    visited.append(next_node)
                    queue.append(next_node)

print(solution())

"""# **74번 최장 경로 찾기**

두 정점 사이를 이동할 수 최장거리를 출력하는 프로그램을 작성해 주세요.
"""

graph = {1: [2, 3, 4],
				 2: [1, 3, 4, 5, 6],
				 3: [1, 2, 7],
				 4: [1, 2, 5, 6],
				 5: [2, 4, 6, 7],
				 6: [2, 4, 5, 7],
				 7: [3, 5, 6]} 

start, end = [int(i) for i in input().split()]
queue = [start]
visited = []

def sol(n, visited):
	if n[-1] == end:
		return len(visited)
	
	if n[-1] in visited:
		return len(visited)
	
	visited.append(n[-1])
	length = 0
	
	for next_node in graph[n[-1]]:
		n.append(next_node)
		length = max(length, sol(n, visited))
		queue.pop(-1)
	return length

print(sol(queue, visited))

"""# **75번 이상한 369**

3이나 6, 9 일 때만 박수를 쳐야합니다. 예를 들어 13, 16과 같이 3과 6, 9 만으로 된 숫자가 아닐 경우엔 박수를 치지 않습니다. 

수현이는 박수를 몇 번 쳤을까요
"""

def sol(n):
    n = list(str(n))
    answer = 0
    count = 1
    d = {3 : 1, 6 : 2, 9 : 3}
    
    while n:
        answer += d[int(n.pop())] * count
        count *= 3
        
    return answer

num = input( ) #입력에 작은따음표 가능한지 '93'
print(sol(num))

"""# **76번 안전한 땅**

각 테스트 케이스에 대해 수색 가능한 범위 bxb 내에서 찾아낼 수 있는 가장 큰 지뢰의 갯수를 구하세요.
"""

import numpy as np

사각형 = 5
탐색가능지역 = 3

지뢰밭 = [[1, 0, 0, 1, 0],
          [0, 1, 0, 0, 1],
          [0, 0, 0, 1, 0],
          [0, 0, 0, 0, 0],
          [0, 0, 1, 0, 0]]

s = 0
for i in range(사각형 - 탐색가능지역 + 1):
    for j in range(탐색가능지역):
        if np.sum(지뢰밭[i:탐색가능지역+i, j:탐색가능지역+j]) > s: 
            s = np.sum(지뢰밭[i:탐색가능지역+i, j:탐색가능지역+j])
print(s)

"""# **77번 가장 긴 공통 부분 문자열**

두 문자열이 주어지면 가장 긴 부분 공통 문자열의 길이를 반환하는 프로그램을 만들어 주세요.

**가장 긴 공통 부분 문자열(Longest Common Subsequence)**이란 A, B 두 문자열이 주어졌을 때
두 열에 공통으로 들어 있는 요소로 만들 수 있는 가장 긴 부분열을 말합니다.
여기서 부분열이란 다른 문자열에서 몇몇의 문자가 빠져 있어도 순서가 바뀌지 않은 열을 말합니다.
"""

def sol(strings):
    result = []
    for i in range(1,len(strings)+1):
        for j in range(i):
            result.append(strings[j:j+len(strings)-i+1])
    return result

input1 = input()
input2 = input()
#문자열 나열될 수 있는 모든 경우의수 만들기
list1 = set(sol(input1))
list2 = set(sol(input2))
#경우의 수 교집합
answers = list1.intersection(list2)
# 가장 긴 교집합
answer = max(answers,key=len)
print(len(answer))

"""# **78번 원형테이블**

원형테이블에는 N개의 음식들이 있습니다.
한개의 음식을 다 먹으면 그 음식의 시계방향으로 K번째 음식을 먹습니다.
하지만 아직 오지 않은 친구들을 위해 2개의 접시를 남겨야 합니다.

마지막으로 남는 음식은 어떤 접시인가요?

(입력은 2개의 정수로 이루어지며 공백으로 구분되어 입력됩니다.
첫번째 숫자가 음식의 개수 N, 두번째 숫자가 K입니다.
첫번째 가져가는 음식이 K이며 나머지는 첫번째 음식으로부터 시계방향으로 가져갑니다.)
"""

a = input().split(' ')
n, k = a


def sol(n, k):
    i = 0
    #q에 n만큼의 숫자를 넣어준다
    q = [i for i in range(1,n+1)]

    while len(q) > 2:
        if i > len(q)-1:
        #순환하다 i가 q의 길이보다 클 경우에 len(q)만큼 빼준다.
        #[1,2,3,4,5,6] -> 1다음 4가 빠지고 그 다음은 4+3 = 7(index : 6)이 빠져야 하는데 
        #i(현재 빠져야 할 index)가 len(q)보다 크므로 len(q)즉, 4를 빼준다. 
        #이걸 마지막 2개가 남을 때 까지 반복함
            i -= len(q)
        q.pop(i)
        i += k
        i -= 1
    print(q)
sol(int(n),int(k))

"""# **79번 순회하는 리스트**

변하기 전 원소와 변한 후 원소의 값의 차가 가장 작은 값을 출력하는 프로그램을 작성하세요.
"""

l = [10, 20, 25, 27, 34, 35, 39]
n = int(input('순회 횟수는 :'))

def rotate(inL, inN):

  def sol(a, t):
    b = a.copy()
    c = []
    for i in range(t):
        b.insert(0, b.pop())
    for i, j in zip(a,b):
        c.append(abs(i-j))
    index = c.index(min(c))
    print("index :", index)
    print("value :", a[index], b[index])
  sol(l, turn)      

rotate(l, n)

"""# **80번 순열과 조합**


한글의 자모 24자 중 자음은 총 14개 입니다.
이 중 입력받은 자음을 n개를 선택하여 나올 수 있는 모든 조합과, 조합의 수를 출력하고 싶습니다.

1. 첫 줄에 선택할 한글 자음이 주어집니다.
2. 두번째 줄에 조합의 수가 주어집니다.
3. 주어진 조합의 수에 따라 조합과 조합의 수를 출력해주세요.
"""

from itertools import permutations #이 문제에서는 안쓰지만 어떤 것인지 확인해보세요.
from itertools import combinations

import itertools

user_input = input().split(',')
user_input_int = int(input())

result = list(itertools.combinations(user_input, 3))

print(list(map(''.join, combinations(user_input, user_input_int))))
print("%s" % len(result))
# -*- coding: utf-8 -*-
"""51-70.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18uVOK9zoKnwP02nCYUYG_dMJ6hyABN0I

# **51번 Merge sort(병합정렬)를 만들어보자**


1. 리스트의 길이가 0 또는 1이면 이미 정렬된 것
2. 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
3. 각 부분의 리스트를 개쥐적으로 합병 정렬을 이용해 정렬한다.
4. 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.
"""

#병합 정렬
def 병합정렬(입력리스트):
    입력리스트길이 = len(입력리스트)
    if 입력리스트길이 <= 1:
        return 입력리스트
    중간값 = 입력리스트길이 // 2
    그룹_하나 = 병합정렬(입력리스트[:중간값])
    그룹_둘 = 병합정렬(입력리스트[중간값:])
    결과값 = []

    while 그룹_하나 and 그룹 둘 :
        if 그룹_하나[0]<그룹_둘[0]:
            결과값.append(그룹_하나.pop(0))
        else:
            결과값.append(그룹_둘.pop(0))

    while 그룹_하나:
        결과값.append(그룹_하나.pop(0))
    while 그룹_둘:
        결과값.append(그룹_둘.pop(0))
    return 결과값

주어진리스트 = [180, 145, 165, 45, 170, 175, 173, 171]
주어진리스트 = input().split(' ')
주어진리스트 = [int(i) for i in 주어진리스트]

print(병합정렬(주어진리스트))

"""# **52번 quick sort**"""

def 퀵정렬(입력리스트):
    입력리스트의길이 = len(입력리스트)
    if 입력리스트의길이 <= 1:
        return 입력리스트
    기준값 = 입력리스트.pop(입력리스트의길이//2)
    그룹_하나 = []
    그룹_둘 = []
    
    for i in range(입력리스트의길이-1):
        if 입력리스트[i] < 기준값
            그룹_하나.append(입력리스트[i])
        else:
            그룹_둘.append(입력리스트[i])
    return 퀵정렬(그룹_하나) + [기준값] + 퀵정렬(그룹_둘)

주어진리스트 = input().split(' ')
주어진리스트 = [int(i) for i in 주어진리스트]

print(퀵정렬(주어진리스트))

"""# **53번 괄호 문자열**

입력으로 주어진 괄호 문자열이 바른 문자열인지 바르지 않은 문자열인지 "YES"와 "NO"로 구분된 문자열을 출력해보세요
"""

def math(e):
  if e.count('(') != e.count(')'):
     return False
  괄호 = []
  for i in e:
    if i == '(':
      괄호.append('(')
    if i == ')':
      if len(괄호) == 0:
        return False
      괄호.pop()
  return True

n = input()
if math(n) == True:
  print("yes")
else: 
  print("no")

"""# **54번 연속되는 수**

스탬프에 적힌 숫자가 공백으로 구분되어 주어지면 이 숫자가 연속수인지 아닌지 "YES"와 "NO"로 판별하는 프로그램을 작성하세요.
"""

user_input = input().split(' ')
user_input = [int(i) for i in user_input]

def sol(l):
  l = sorted(l)
  for i in range(len(l)-1):
    if l[i]+1 != l[i+1]:
      return 'no'
  return 'yes'

print (sol(user_input))

"""# **55번 하노이의 탑**

1. 처음에 모든 원판은 A기둥에 꽂혀 있다.
2. 모든 원판의 지름은 다르다.
3. 이 원반은 세개의 기둥 중 하나에 반드시 꽂혀야 한다.
4. 작은 원반 위에 큰 원반을 놓을 수 없다.
5. 한 번에 하나의 원판(가장 위에 있는 원판)만을 옮길 수 있다.

이 규칙을 만족하며 A기둥에 있는 원반 N개를 모두 C 원반으로 옮기고 싶습니다.
모든 원반을 옮기기 위해 실행되어야 할 최소 원반 이동 횟수를 계산하는 프로그램을 완성해주세요.
"""

원판의이동경로 = []
def 하노이(원반의수, 시작기둥, 목표기둥, 보조기둥):
    #원판이 한개일 때에는 옮기면 됩니다.
    if 원반의수 == 1:
        원판의이동경로.append([시작기둥, 목표기둥]) 
        return None
    #원반의 n-1개를 경유기둥으로 옮기고
    하노이(원반의수-1, 시작기둥, 보조기둥, 목표기둥)
    #가장 큰 원반은 목표기둥으로
    원판의이동경로.append([시작기둥, 목표기둥]) 
    #경유기둥과 시작기둥을 바꿉니다!
    하노이(원반의수-1, 보조기둥, 목표기둥, 시작기둥)
 
print('원반의 개수')
user_input = int(input())
하노이(user_input,'A','C','B')
print(원판의이동경로)
print(len(원판의이동경로))

"""# **56번 리스트의 함수 응용**

다음의 딕셔너리가 주어졌을 때 한국의 면적과 가장 비슷한 국가와 그 차이를 출력하세요.
"""

nationWidth = {
	'korea': 220877, 
	'Rusia': 17098242, 
	'China': 9596961, 
	'France': 543965, 
	'Japan': 377915,
	'England' : 242900,
}

w = nationWidth['korea']
nationWidth.pop('korea')
l = list(nationWidth.items())
gap = max(nationWidth.values())
item = 0

for i in l:
    if gap > abs(i[1] - w):
        gap = abs(i[1] - w)
        item = i
print(item[0],item[1]-220877)

"""# **57번 내장함수 응용하기**

0부터 1000까지 1의 개수를 세는 프로그램을 만들려고 합니다. 예를 들어 0부터 20까지 1의 개수를 세어본다면 1, 10 11, 12, 13, 14, 15, 16, 17, 18, 19 에 각각 1이 들어가므로 12개의 1이 있게 됩니다. 11은 1이 2번 들어간 셈이죠.

그렇다면 0부터 1000까지 수에서 1은 몇번이나 들어갔을까요? 출력해주세요!
"""

def count(n):
	countN = str(list(range(n+1))).count('1')
	return countN

print(count(1000))

"""# **58번 콤마 찍기**

원범이는 편의점 아르바이트가 끝난 후 정산을 하고자 합니다.
정산을 빨리하고 집에가고 싶은 원범이는 프로그램을 만들려고 합니다.

숫자를 입력 받고 천단위로 콤마(,)를 찍어주세요.

"""

n = int(input())

result = format(n, ',')
print(result)

"""# **59번 빈칸채우기**

총 문자열의 길이는 50으로 제한하고 사용자가 문자열을 입력하면 그 문자열을 가운데 정렬을 해주고, 나머지 빈 부분에는 '='을 채워넣어주세요
"""

user_input = input()
print("{0:=^50}".format(user_input))

"""# **60번 enumerate**

새학기가 되어 이름을 가나다 순서대로 배정하고 번호를 매기려고 합니다.
코드에 입력된 이름을 아래와 같이 출력해주세요.
"""

students = ['강은지','김유정','박현서','최성훈','홍유진','박지호','권윤일','김채리','한지호','김진이','김민호','강채연'] 
students = sorted(students) #기본 오름차순 정렬 reverse=True 내림차순가능

for number, name in enumerate(students): #enumerate 인덱스를 붙여줌
  print("번호: {}, 이름: {}".format(number+1, name))

"""# **61번 문자열 압축하기**

문자열을 입력받고 연속되는 문자열을 압축해서 표현해보세요.
"""

user_input = input()
s = ''
storeString = user_input[0]
count = 0
for i in user_input:
    if i == storeString:
        count += 1
    else:
        s += str(count) + storeString
        storeString = i
        count = 1
s += str(count) + storeString
print(s)

"""# **62번 20190923 출력하기**

1. 코드 내에 숫자가 없어야 합니다.
  - 예) print(20190923)이라고 하시면 안됩니다.
2. 파일 이름이나 경로를 사용해서는 안됩니다.
3. 시간, 날짜 함수를 사용해서는 안됩니다.
4. 에러 번호 출력을 이용해서는 안됩니다.
5. input을 이용해서는 안됩니다.
"""

string='aacddddddddd'
a=string.count('a') #2
b=string.count('b') #0
c=string.count('c') #1
d=string.count('d') #9
print(int(str(a)+str(b)+str(c)+str(d)+str(b)+str(d)+str(a)+str(a+1)))

"""# **63번 친해지고 싶어**

어떤 입력이 주어지면 앞 글자만 줄여 출력하도록 해보세요.

"""

user_input=input().split() #문자열을 나누어 준다. 
result = ''

for s in user_input:
  result += s[0]

print(result)

"""# **64번 이상한 엘리베이터**

정량 N에 정확히 맞춰야만 움직이는 화물용 엘레베이터가 있습니다.
화물은 7kg, 3kg 두 가지이며 팔이 아픈 은후는 가장 적게 화물을 옮기고 싶습니다.

**입력**
정량 N이 입력됩니다.

**출력**
가장 적게 옮길 수 있는 횟수를 출력합니다.
만약 어떻게 해도 정량이 N이 되지 않는다면 -1을 출력합니다.
"""

N = int(input())
result = 0

while True:
    if N%7 ==0:
        result += N//7
        print(result)
        break
    N -= 3
    result += 1
    if N < 0:
        print(-1)
        break

"""# **65번 변형된 리스트**

a = [1,2,3,4]
b = [a,b,c,d]
이런 리스트가 있을 때 [[1,a],[b,2],[3,c],[d,4]] 이런식으로 a,b리스트가 번갈아가면서 출력되게 해주세요.
"""

a = input().split(' ')
b = input().split(' ')

c = []
count = 0

for i, j in zip(a, b):
	if count % 2 == 0:
		c.append([i, j])
	else:
		c.append([j, i])
	count += 1

print(c)

# [[1,'a'],['b',2],[3,'c'],['d',4]]

"""# **66번 불럭탑쌓기**

탑을 쌓기 위해 각 크기별로 준비된 블럭들을 정해진 순서에 맞게 쌓아햐 합니다.
순서에 맞게 쌓지 않으면 무너질 수 있습니다.
예를 들면 정해진 순서가 BAC 라면 A 다음 C가 쌓아져야 합니다.
선행으로 쌓아야 하는 블럭이 만족된 경우라면 탑이 무너지지 않습니다.

- B를 쌓지 않아도 A와 C를 쌓을 수 있습니다.
- B 다음 블럭이 C가 될 수 있습니다.

쌓아져 있는 블럭 탑이 순서에 맞게 쌓아져 있는지 확인하세요.

1. 블럭은 알파벳 대문자로 표기합니다.
2. 규칙에 없는 블럭이 사용될 수 있습니다.
3. 중복된 블럭은 존재하지 않습니다.
"""

def solution(전체블록, 규칙):
    answer = []
    for 부분블록 in 전체블록:
        answer.append(블록순서체크(부분블록, 규칙))
    return answer

def 블록순서체크(부분블록, 규칙):
    임시변수 = 규칙.index(규칙[0])
    for 문자 in 부분블록:
        if 문자 in 규칙:
            if 임시변수 > 규칙.index(문자):
                return '불가능'
            임시변수 = 규칙.index(문자)
    return '가능'

전체블록 = ['ABCDEF', 'BCAD', 'ADEFQRX', 'BEDFG', 'AEBFDGCH']
규칙 = 'ABCD'

print(solution(전체블록, 규칙))

"""# **67번 민규의 악수**

광장에서 모인 사람들과 악수를 하는 행사가 열렸다.
참가자인 민규는 몇명의 사람들과 악수를 한 후 중간에 일이 생겨 집으로 갔다.
이 행사에서 진행된 악수는 총 n번이라고 했을때.

민규는 몇번의 악수를 하고 집으로 돌아갔을까?
이때 민규를 포함한 행사 참가자는 몇명일까?

- 악수는 모두 1대 1로 진행이 된다.
- 민규를 제외한 모든 참가자는 자신을 제외한 참가자와 모두 한번씩 악수를 한다.
- 같은 상대와 중복된 악수는 카운트 하지 않는다.
- 민규를 제외한 참가자는 행사를 모두 마쳤다.

"""

def solution(n):
    people = 0
    total = 0
    while(True):
        total = people*(people-1)/2
        if n<total:
            break
        people+=1
    times = int(people-(total-n)-1)
    return [times,people]

"""# **68번 버스시간표**

학교가 끝난 지원이는 집에 가려고 합니다. 학교 앞에 있는 버스 시간표는 너무 복잡해서 버스 도착시간이 몇 분 남았는지 알려주는 프로그램을 만들고 싶습니다.
버스시간표와 현재 시간이 주어졌을 때 버스 도착 시간이 얼마나 남았는지 알려주는 프로그램을 만들어주세요.

- 버스 시간표와 현재시간이 입력으루 주어집니다.
- 출력 포맷은 "00시00분"입니다.
   만약 1시간 3분이 남았다면 "01시간03분"으로 출력해야 합니다.
- 버스 시간표에 현재 시간보다 이전인 버스가 있다면 "지나갔습니다."라고 출력합니다.

"""

def sol(tb, rt):
    answer = []
    rt = rt.split(':')
    for i in range(len(tb)):
        time = tb[i].split(':')
        time_to_min = ((int(time[0])*60 + int(time[1])) - (int(rt[0])*60+int(rt[1])))
        if time_to_min < 0:
            answer.append("지나갔습니다")
        else:
            a = (time_to_min) // 60
            b = (time_to_min) % 60
            answer.append(str(a).zfill(2)+'시간 '+str(b).zfill(2)+'분')
    return answer

sol(["12:30", "13:20", "14:13"], "12:40")

"""# **69번 골드바흐의 추측**

골드바흐의 추측(Goldbach's conjecture)은 오래전부터 알려진 정수론의 미해결 문제로, 2보다 큰 모든 짝수는 두 개의 소수(Prime number)의 합으로 표시할 수 있다는 것이다. 이때 하나의 소수를 두 번 사용하는 것은 허용한다. - 위키백과

위 설명에서 2보다 큰 모든 짝수를 두 소수의 합으로 나타낸 것을 골드바흐 파티션이라고 합니다.

예)
100 == 47 + 53
56 == 19 + 37

2보다 큰 짝수 n이 주어졌을 때, 골드바흐 파티션을 출력하는 코드를 작성하세요. 
"""

def cal():
    n=10000*2
    primes=[]    
    a = [False,False] + [True]*(n-1)

    for i in range(2,n+1):
      if a[i]:
        primes.append(i)
        for j in range(2*i, n+1, i):
            a[j] = False
            
    return primes


a = cal()

#골드바흐파티션
n = int(input())
l = []
k = []	

for i in range(2, n//2+1):    
    if i in a and n-i in a:
        l.append(i)
        l.append(n-i)

for i in range(0,len(l)-1,2):
    k.append(l[i+1]-l[i])
    
index = k.index(min(k))*2
print(l[index], l[index+1])

"""# **70번 행렬 곱하기**

행렬 2개가 주어졌을 때 곱할 수 있는 행렬인지 확인하고 곱할 수 있다면 그 결과를, 곱할 수 없다면 -1을 출력하는 프로그램을 만들어주세요.
"""

def sol(a, b):
    c = []
    if len(a) == len(b[0]):
        for i in range(len(a)):
            c.append([0]*len(b[0]))
        for i in range(len(c)):
            for j in range(len(c[i])):
                for k in range(len(a[i])):
                    c[i][j] += a[i][k] * b[k][j]
        return c
    else:
        return -1